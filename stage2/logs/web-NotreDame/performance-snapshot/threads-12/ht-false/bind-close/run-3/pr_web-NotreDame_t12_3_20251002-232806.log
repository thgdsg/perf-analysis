vtune: Peak bandwidth measurement started.
vtune: Peak bandwidth measurement finished.
vtune: Collection started. To stop the collection, either press CTRL-C or enter from another console window: vtune -r /scratch/tsgoncalves/perf-analysis/stage2/results/web-NotreDame/performance-snapshot/threads-12/ht-false/bind-close/run-3 -command stop.
Read Time:           0.19753
Build Time:          0.01157
Graph has 325729 nodes and 1469679 directed edges for degree: 4
Trial Time:          0.01702
Trial Time:          0.01710
Trial Time:          0.01691
Trial Time:          0.01690
Trial Time:          0.01698
Trial Time:          0.01694
Trial Time:          0.01693
Trial Time:          0.01694
Trial Time:          0.01695
Trial Time:          0.01695
Trial Time:          0.01696
Trial Time:          0.01693
Trial Time:          0.01696
Trial Time:          0.01692
Trial Time:          0.01701
Trial Time:          0.01685
Average Time:        0.01695
vtune: Collection stopped.
vtune: Using result path `/scratch/tsgoncalves/perf-analysis/stage2/results/web-NotreDame/performance-snapshot/threads-12/ht-false/bind-close/run-3'
vtune: Executing actions  0 %                                                  vtune: Executing actions  0 % Finalizing results                               vtune: Executing actions  0 % Finalizing the result                            vtune: Executing actions  0 % Clearing the database                            vtune: Executing actions  7 % Clearing the database                            vtune: Executing actions  7 % Loading raw data to the database                 vtune: Executing actions  7 % Loading 'systemcollector-72867-blaise.sc' file   vtune: Executing actions 12 % Loading 'systemcollector-72867-blaise.sc' file   vtune: Executing actions 12 % Loading '72877.stat.perf' file                   vtune: Executing actions 12 % Updating precomputed scalar metrics              vtune: Executing actions 14 % Updating precomputed scalar metrics              vtune: Executing actions 14 % Processing profile metrics and debug information vtune: Executing actions 19 % Processing profile metrics and debug information vtune: Executing actions 19 % Setting data model parameters                    vtune: Executing actions 19 % Resolving module symbols                         vtune: Executing actions 19 % Resolving thread name information                vtune: Executing actions 21 % Resolving thread name information                vtune: Executing actions 21 % Resolving call target names for dynamic code     vtune: Executing actions 24 % Resolving call target names for dynamic code     vtune: Executing actions 24 % Resolving interrupt name information             vtune: Executing actions 26 % Resolving interrupt name information             vtune: Executing actions 26 % Processing profile metrics and debug information vtune: Executing actions 28 % Processing profile metrics and debug information vtune: Executing actions 29 % Processing profile metrics and debug information vtune: Executing actions 30 % Processing profile metrics and debug information vtune: Executing actions 31 % Processing profile metrics and debug information vtune: Executing actions 31 % Preparing output tree                            vtune: Executing actions 31 % Parsing columns in input tree                    vtune: Executing actions 32 % Parsing columns in input tree                    vtune: Executing actions 32 % Creating top-level columns                       vtune: Executing actions 32 % Creating top-level rows                          vtune: Executing actions 33 % Creating top-level rows                          vtune: Executing actions 33 % Preparing output tree                            vtune: Executing actions 33 % Parsing columns in input tree                    vtune: Executing actions 33 % Creating top-level columns                       vtune: Executing actions 34 % Creating top-level columns                       vtune: Executing actions 34 % Creating top-level rows                          vtune: Executing actions 35 % Creating top-level rows                          vtune: Executing actions 35 % Setting data model parameters                    vtune: Executing actions 35 % Precomputing frequently used data                vtune: Executing actions 35 % Precomputing frequently used data                vtune: Executing actions 36 % Precomputing frequently used data                vtune: Executing actions 37 % Precomputing frequently used data                vtune: Executing actions 38 % Precomputing frequently used data                vtune: Executing actions 39 % Precomputing frequently used data                vtune: Executing actions 40 % Precomputing frequently used data                vtune: Executing actions 41 % Precomputing frequently used data                vtune: Executing actions 41 % Updating precomputed scalar metrics              vtune: Executing actions 42 % Updating precomputed scalar metrics              vtune: Executing actions 42 % Discarding redundant overtime data               vtune: Executing actions 44 % Discarding redundant overtime data               vtune: Executing actions 44 % Saving the result                                vtune: Executing actions 46 % Saving the result                                vtune: Executing actions 48 % Saving the result                                vtune: Executing actions 49 % Saving the result                                vtune: Executing actions 50 % Saving the result                                vtune: Executing actions 50 % Generating a report                              vtune: Executing actions 50 % Setting data model parameters                    vtune: Executing actions 75 % Setting data model parameters                    vtune: Executing actions 75 % Generating a report                              Elapsed Time: 0.545s
    IPC: 0.959
     | The IPC may be too low. This could be caused by issues such as memory
     | stalls, instruction starvation, branch misprediction or long latency
     | instructions. Explore the other hardware-related metrics to identify what
     | is causing low IPC.
     |
    SP GFLOPS: 1.515
    DP GFLOPS: 0.169
    x87 GFLOPS: 0.008
    Average CPU Frequency: 3.113 GHz 
Effective Logical Core Utilization: 8.1% (7.138 out of 88)
 | The metric value is low, which may signal a poor logical CPU cores
 | utilization. Consider improving physical core utilization as the first step
 | and then look at opportunities to utilize logical cores, which in some cases
 | can improve processor throughput and overall performance of multi-threaded
 | applications.
 |
    Effective Physical Core Utilization: 8.5% (3.719 out of 44)
     | The metric value is low, which may signal a poor physical CPU cores
     | utilization caused by:
     |     - load imbalance
     |     - threading runtime overhead
     |     - contended synchronization
     |     - thread/process underutilization
     |     - incorrect affinity that utilizes logical cores instead of physical
     |       cores
     | Explore sub-metrics to estimate the efficiency of MPI and OpenMP
     | parallelism or run the Locks and Waits analysis to identify parallel
     | bottlenecks for other parallel runtimes.
     |
Microarchitecture Usage: 47.2% of Pipeline Slots
 | You code efficiency on this platform is too low.
 | 
 | Possible cause: memory stalls, instruction starvation, branch misprediction
 | or long latency instructions.
 | 
 | Next steps: Run Microarchitecture Exploration analysis to identify the cause
 | of the low microarchitecture usage efficiency.
 |
    Retiring: 47.2% of Pipeline Slots
    Front-End Bound: 21.9% of Pipeline Slots
     | Issue: A significant portion of Pipeline Slots is remaining empty due to
     | issues in the Front-End.
     | 
     | Tips:  Make sure the code working size is not too large, the code layout
     | does not require too many memory accesses per cycle to get enough
     | instructions for filling four pipeline slots, or check for microcode
     | assists.
     |
    Back-End Bound: 17.9% of Pipeline Slots
        Memory Bound: 7.4% of Pipeline Slots
        Core Bound: 10.5% of Pipeline Slots
    Bad Speculation: 13.0% of Pipeline Slots
Memory Bound: 7.4% of Pipeline Slots
    L1 Bound: 18.1% of Clockticks
    L2 Bound: 0.7% of Clockticks
    L3 Bound: 2.8% of Clockticks
    DRAM Bound: 0.2% of Clockticks
        DRAM Bandwidth Bound: 0.0% of Elapsed Time
    Store Bound: 0.2% of Clockticks
    NUMA: % of Remote Accesses: 52.4%
Vectorization: 0.0% of Packed FP Operations
 | A significant fraction of floating point arithmetic instructions are scalar.
 | Use Intel Advisor to see possible reasons why the code was not vectorized.
 |
    Instruction Mix
        SP FLOPs: 6.9% of uOps
            Packed: 0.0% from SP FP
                128-bit: 0.0% from SP FP
                256-bit: 0.0% from SP FP
            Scalar: 100.0% from SP FP
             | This code has floating point operations and is not vectorized.
             | Consider using Intel Advisor to vectorize the loops.
             |
        DP FLOPs: 0.8% of uOps
            Packed: 0.0% from DP FP
                128-bit: 0.0% from DP FP
                256-bit: 0.0% from DP FP
            Scalar: 100.0% from DP FP
             | This code has floating point operations and is not vectorized.
             | Consider using Intel Advisor to vectorize the loops.
             |
        x87 FLOPs: 0.0% of uOps
        Non-FP: 92.2% of uOps
    FP Arith/Mem Rd Instr. Ratio: 0.284
     | The metric value is low. This can be a result of unaligned access to data
     | for vector operations. Use Intel Advisor to find possible data access
     | inefficiencies for vector operations.
     |
    FP Arith/Mem Wr Instr. Ratio: 1.638
Collection and Platform Info
    Application Command Line: /scratch/tsgoncalves/perf-analysis/stage2/src/gapbs/pr "-f" "./data/web-NotreDame/web-NotreDame.el" "-i" "500" "-t" "1e-6" 
    Operating System: 4.19.0-25-amd64 10.13
    Computer Name: blaise
    Result Size: 3.6 MB 
    Collection start time: 02:28:16 03/10/2025 UTC
    Collection stop time: 02:28:16 03/10/2025 UTC
    Collector Type: Driverless Perf per-process counting
    CPU
        Name: Intel(R) Xeon(R) Processor code named Broadwell
        Frequency: 2.200 GHz 
        Logical CPU Count: 88
        Max DRAM Single-Package Bandwidth: 70.000 GB/s
        Cache Allocation Technology
            Level 2 capability: not detected
            Level 3 capability: available

Recommendations:
    Hotspots: Start with Hotspots analysis to understand the efficiency of your algorithm.
     | Use Hotspots analysis to identify the most time consuming functions.
     | Drill down to see the time spent on every line of code.
    Threading: There is poor utilization of logical CPU cores (8.1%) in your application. 
     |  Use Threading to explore more opportunities to increase parallelism in
     | your application.
    Microarchitecture Exploration: There is low microarchitecture usage (47.2%) of available hardware resources. 
     | Run Microarchitecture Exploration analysis to analyze CPU
     | microarchitecture bottlenecks that can affect application performance.

If you want to skip descriptions of detected performance issues in the report,
enter: vtune -report summary -report-knob show-issues=false -r <my_result_dir>.
Alternatively, you may view the report in the csv format: vtune -report
<report_name> -format=csv.
vtune: Executing actions 100 % Generating a report                             vtune: Executing actions 100 % done                                            
