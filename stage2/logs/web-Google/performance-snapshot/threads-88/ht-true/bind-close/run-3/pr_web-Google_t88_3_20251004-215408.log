vtune: Peak bandwidth measurement started.
vtune: Peak bandwidth measurement finished.
vtune: Collection started. To stop the collection, either press CTRL-C or enter from another console window: vtune -r /scratch/tsgoncalves/perf-analysis/stage2/results/web-Google/performance-snapshot/threads-88/ht-true/bind-close/run-3 -command stop.
Read Time:           0.66135
Build Time:          0.03375
Graph has 916428 nodes and 5105039 directed edges for degree: 5
Trial Time:          0.04459
Trial Time:          0.04254
Trial Time:          0.04141
Trial Time:          0.04236
Trial Time:          0.04239
Trial Time:          0.04084
Trial Time:          0.04026
Trial Time:          0.04056
Trial Time:          0.04173
Trial Time:          0.04142
Trial Time:          0.04186
Trial Time:          0.04175
Trial Time:          0.04276
Trial Time:          0.04163
Trial Time:          0.04213
Trial Time:          0.04248
Average Time:        0.04192
vtune: Collection stopped.
vtune: Using result path `/scratch/tsgoncalves/perf-analysis/stage2/results/web-Google/performance-snapshot/threads-88/ht-true/bind-close/run-3'
vtune: Executing actions  0 %                                                  vtune: Executing actions  0 % Finalizing results                               vtune: Executing actions  0 % Finalizing the result                            vtune: Executing actions  0 % Clearing the database                            vtune: Executing actions  7 % Clearing the database                            vtune: Executing actions  7 % Loading raw data to the database                 vtune: Executing actions  7 % Loading 'systemcollector-88274-blaise.sc' file   vtune: Executing actions 12 % Loading 'systemcollector-88274-blaise.sc' file   vtune: Executing actions 12 % Loading '88284.stat.perf' file                   vtune: Executing actions 12 % Updating precomputed scalar metrics              vtune: Executing actions 14 % Updating precomputed scalar metrics              vtune: Executing actions 14 % Processing profile metrics and debug information vtune: Executing actions 19 % Processing profile metrics and debug information vtune: Executing actions 19 % Setting data model parameters                    vtune: Executing actions 19 % Resolving module symbols                         vtune: Executing actions 19 % Resolving thread name information                vtune: Executing actions 21 % Resolving thread name information                vtune: Executing actions 21 % Resolving call target names for dynamic code     vtune: Executing actions 24 % Resolving call target names for dynamic code     vtune: Executing actions 24 % Resolving interrupt name information             vtune: Executing actions 26 % Resolving interrupt name information             vtune: Executing actions 26 % Processing profile metrics and debug information vtune: Executing actions 28 % Processing profile metrics and debug information vtune: Executing actions 29 % Processing profile metrics and debug information vtune: Executing actions 30 % Processing profile metrics and debug information vtune: Executing actions 31 % Processing profile metrics and debug information vtune: Executing actions 31 % Preparing output tree                            vtune: Executing actions 31 % Parsing columns in input tree                    vtune: Executing actions 32 % Parsing columns in input tree                    vtune: Executing actions 32 % Creating top-level columns                       vtune: Executing actions 32 % Creating top-level rows                          vtune: Executing actions 33 % Creating top-level rows                          vtune: Executing actions 33 % Preparing output tree                            vtune: Executing actions 33 % Parsing columns in input tree                    vtune: Executing actions 33 % Creating top-level columns                       vtune: Executing actions 34 % Creating top-level columns                       vtune: Executing actions 34 % Creating top-level rows                          vtune: Executing actions 35 % Creating top-level rows                          vtune: Executing actions 35 % Setting data model parameters                    vtune: Executing actions 35 % Precomputing frequently used data                vtune: Executing actions 35 % Precomputing frequently used data                vtune: Executing actions 36 % Precomputing frequently used data                vtune: Executing actions 37 % Precomputing frequently used data                vtune: Executing actions 38 % Precomputing frequently used data                vtune: Executing actions 39 % Precomputing frequently used data                vtune: Executing actions 40 % Precomputing frequently used data                vtune: Executing actions 41 % Precomputing frequently used data                vtune: Executing actions 41 % Updating precomputed scalar metrics              vtune: Executing actions 42 % Updating precomputed scalar metrics              vtune: Executing actions 42 % Discarding redundant overtime data               vtune: Executing actions 44 % Discarding redundant overtime data               vtune: Executing actions 44 % Saving the result                                vtune: Executing actions 46 % Saving the result                                vtune: Executing actions 48 % Saving the result                                vtune: Executing actions 49 % Saving the result                                vtune: Executing actions 50 % Saving the result                                vtune: Executing actions 50 % Generating a report                              vtune: Executing actions 50 % Setting data model parameters                    vtune: Executing actions 75 % Setting data model parameters                    vtune: Executing actions 75 % Generating a report                              Elapsed Time: 1.443s
    IPC: 0.629
     | The IPC may be too low. This could be caused by issues such as memory
     | stalls, instruction starvation, branch misprediction or long latency
     | instructions. Explore the other hardware-related metrics to identify what
     | is causing low IPC.
     |
    SP GFLOPS: 2.428
    DP GFLOPS: 0.326
    x87 GFLOPS: 0.007
    Average CPU Frequency: 2.802 GHz 
Effective Logical Core Utilization: 14.6% (12.812 out of 88)
 | The metric value is low, which may signal a poor logical CPU cores
 | utilization. Consider improving physical core utilization as the first step
 | and then look at opportunities to utilize logical cores, which in some cases
 | can improve processor throughput and overall performance of multi-threaded
 | applications.
 |
    Effective Physical Core Utilization: 29.3% (12.871 out of 44)
     | The metric value is low, which may signal a poor physical CPU cores
     | utilization caused by:
     |     - load imbalance
     |     - threading runtime overhead
     |     - contended synchronization
     |     - thread/process underutilization
     |     - incorrect affinity that utilizes logical cores instead of physical
     |       cores
     | Explore sub-metrics to estimate the efficiency of MPI and OpenMP
     | parallelism or run the Locks and Waits analysis to identify parallel
     | bottlenecks for other parallel runtimes.
     |
Microarchitecture Usage: 13.2% of Pipeline Slots
 | You code efficiency on this platform is too low.
 | 
 | Possible cause: memory stalls, instruction starvation, branch misprediction
 | or long latency instructions.
 | 
 | Next steps: Run Microarchitecture Exploration analysis to identify the cause
 | of the low microarchitecture usage efficiency.
 |
    Retiring: 13.2% of Pipeline Slots
    Front-End Bound: 6.4% of Pipeline Slots
    Back-End Bound: 66.6% of Pipeline Slots
     | A significant portion of pipeline slots are remaining empty. When
     | operations take too long in the back-end, they introduce bubbles in the
     | pipeline that ultimately cause fewer pipeline slots containing useful
     | work to be retired per cycle than the machine is capable to support. This
     | opportunity cost results in slower execution. Long-latency operations
     | like divides and memory operations can cause this, as can too many
     | operations being directed to a single execution port (for example, more
     | multiply operations arriving in the back-end per cycle than the execution
     | unit can support).
     |
        Memory Bound: 48.4% of Pipeline Slots
         | The metric value is high. This can indicate that the significant
         | fraction of execution pipeline slots could be stalled due to demand
         | memory load and stores. Use Memory Access analysis to have the metric
         | breakdown by memory hierarchy, memory bandwidth information,
         | correlation by memory objects.
         |
        Core Bound: 18.2% of Pipeline Slots
         | This metric represents how much Core non-memory issues were of a
         | bottleneck. Shortage in hardware compute resources, or dependencies
         | software's instructions are both categorized under Core Bound. Hence
         | it may indicate the machine ran out of an OOO resources, certain
         | execution units are overloaded or dependencies in program's data- or
         | instruction- flow are limiting the performance (e.g. FP-chained long-
         | latency arithmetic operations).
         |
    Bad Speculation: 13.8% of Pipeline Slots
Memory Bound: 48.4% of Pipeline Slots
 | The metric value is high. This can indicate that the significant fraction of
 | execution pipeline slots could be stalled due to demand memory load and
 | stores. Use Memory Access analysis to have the metric breakdown by memory
 | hierarchy, memory bandwidth information, correlation by memory objects.
 |
    L1 Bound: 14.7% of Clockticks
     | This metric shows how often machine was stalled without missing the L1
     | data cache. The L1 cache typically has the shortest latency. However, in
     | certain cases like loads blocked on older stores, a load might suffer a
     | high latency even though it is being satisfied by the L1.
     |
    L2 Bound: 0.0% of Clockticks
    L3 Bound: 41.3% of Clockticks
     | This metric shows how often CPU was stalled on L3 cache, or contended
     | with a sibling Core. Avoiding cache misses (L2 misses/L3 hits) improves
     | the latency and increases performance.
     |
    DRAM Bound: 7.0% of Clockticks
        DRAM Bandwidth Bound: 0.0% of Elapsed Time
    Store Bound: 11.6% of Clockticks
    NUMA: % of Remote Accesses: 45.4%
Vectorization: 0.0% of Packed FP Operations
 | A significant fraction of floating point arithmetic instructions are scalar.
 | Use Intel Advisor to see possible reasons why the code was not vectorized.
 |
    Instruction Mix
        SP FLOPs: 12.7% of uOps
            Packed: 0.0% from SP FP
                128-bit: 0.0% from SP FP
                256-bit: 0.0% from SP FP
            Scalar: 100.0% from SP FP
             | This code has floating point operations and is not vectorized.
             | Consider using Intel Advisor to vectorize the loops.
             |
        DP FLOPs: 1.7% of uOps
            Packed: 0.0% from DP FP
                128-bit: 0.0% from DP FP
                256-bit: 0.0% from DP FP
            Scalar: 100.0% from DP FP
             | This code has floating point operations and is not vectorized.
             | Consider using Intel Advisor to vectorize the loops.
             |
        x87 FLOPs: 0.0% of uOps
        Non-FP: 85.5% of uOps
    FP Arith/Mem Rd Instr. Ratio: 0.348
     | The metric value is low. This can be a result of unaligned access to data
     | for vector operations. Use Intel Advisor to find possible data access
     | inefficiencies for vector operations.
     |
    FP Arith/Mem Wr Instr. Ratio: 1.596
Collection and Platform Info
    Application Command Line: /scratch/tsgoncalves/perf-analysis/stage2/src/gapbs/pr "-f" "./data/web-Google/web-Google.el" "-i" "500" "-t" "1e-6" 
    Operating System: 4.19.0-25-amd64 10.13
    Computer Name: blaise
    Result Size: 3.6 MB 
    Collection start time: 00:54:17 05/10/2025 UTC
    Collection stop time: 00:54:19 05/10/2025 UTC
    Collector Type: Driverless Perf per-process counting
    CPU
        Name: Intel(R) Xeon(R) Processor code named Broadwell
        Frequency: 2.200 GHz 
        Logical CPU Count: 88
        Max DRAM Single-Package Bandwidth: 84.000 GB/s
        Cache Allocation Technology
            Level 2 capability: not detected
            Level 3 capability: available

Recommendations:
    Hotspots: Start with Hotspots analysis to understand the efficiency of your algorithm.
     | Use Hotspots analysis to identify the most time consuming functions.
     | Drill down to see the time spent on every line of code.
    Memory Access: The Memory Bound metric is high  (48.4%). A significant fraction of execution pipeline slots could be stalled due to demand memory load and stores. 
     | Use Memory Access analysis to measure metrics that can identify memory
     | access issues.
    Threading: There is poor utilization of logical CPU cores (14.6%) in your application. 
     |  Use Threading to explore more opportunities to increase parallelism in
     | your application.

If you want to skip descriptions of detected performance issues in the report,
enter: vtune -report summary -report-knob show-issues=false -r <my_result_dir>.
Alternatively, you may view the report in the csv format: vtune -report
<report_name> -format=csv.
vtune: Executing actions 100 % Generating a report                             vtune: Executing actions 100 % done                                            
